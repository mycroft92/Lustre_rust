///Adapting grammar from VÃ©lus repo

// // Identifiers may begin with `_` or an ASCII character.


// file = { SOI ~ node_list ~ EOI }

// node_list = { node* }

// node = { "node" ~ identifier ~ "(" ~ streams_decl ~ ")" ~ "return" ~ streams_decl ~ "let" ~ var}


bool_constant = { "true" | "false" }
identifier    = @{ ("_" | ASCII_ALPHA)+ ~ ("_" | ASCII_ALPHA | ASCII_DIGIT)* }

// (* Integer constants *)
nonzero_digit        = _{ ('1'..'9') }
decimal_constant = { nonzero_digit ~ ASCII_DIGIT* }
octal_digit      = _{('0'..'7')}
octal_constant   = { "0" ~ octal_digit*}
hexadecimal_prefix   = _{ ("0x") | ("0X") }
hexadecimal_digit    = _{ ('A'..'F') | ('a'..'f') | ASCII_DIGIT }
hexadecimal_constant = { hexadecimal_prefix  ~ hexadecimal_digit+ }

//Not using these rules currently
unsigned_suffix  = _{ "u" | "U"}
long_suffix      = _{ "l" | "L"}
long_long_suffix = _{ "ll" | "LL"}
integer_suffix   = {
    (unsigned_suffix  ~ long_suffix?)
  | (unsigned_suffix  ~ long_long_suffix?)
  | (long_suffix      ~ unsigned_suffix?)
  | (long_long_suffix ~ unsigned_suffix?) }

// integer_constant = { (hexadecimal_constant ~ integer_suffix?) | (octal_constant ~ integer_suffix?) | (decimal_constant ~ integer_suffix? ) }

integer_constant = _{ (hexadecimal_constant) | (octal_constant) | (decimal_constant) }

constant         = _{ bool_constant | integer_constant } 

// primary_expression:
// | var=VAR_NAME
//     { [LustreAst.VARIABLE (fst var) (snd var)] }
// | cst=constant
//     { [LustreAst.CONSTANT (fst cst) (snd cst)] }
// | loc=LPAREN expr=expression_list RPAREN
//     { rev expr }
primary_expression = { identifier | constant | expression_list }

// (* 6.5.2 *)
postfix_expression = { 
  (identifier ~ "(" ~ expression_list ~ ")") 
  | ("(" ~  "restart" ~ identifier ~ "every" ~ expression ~ ")" ~ "(" ~ expression_list ~")") 
  | primary_expression }

expression_list    = { expression ~ ( "," ~ expression)* }

// (* 6.5.3 *)
// unary_expression:
// | expr=postfix_expression
//     { expr }
// | op=unary_operator expr=cast_expression
//     { [LustreAst.UNARY (fst op) expr (snd op)] }
// | loc=HASH LPAREN args=expression_list RPAREN
//     {
//       (* Macro expand the Lustre # operator (mutual exclusion: at most
//          one of the variable number of arguments may be true). Compare
// 	 with "true" to ensure that non-bool arguments are properly
// 	 treated. Is there a prettier way to do this? *)
//       [LustreAst.BINARY
//         LustreAst.LE
//         [fold_right (fun es e => LustreAst.BINARY LustreAst.ADD [e] [es] loc)
// 	  (LustreAst.CONSTANT (LustreAst.CONST_INT LustreAst.string_zero) loc)
// 	  (map (fun e=>LustreAst.CAST LustreAst.Tbool [e] loc)
// 	   args)]
// 	[LustreAst.CONSTANT (LustreAst.CONST_INT LustreAst.string_one) loc]
// 	loc]
//     }
unary_expression = { 
  ("#" ~ "(" ~ expression_list  ~ ")")
  | unary_operator ~ cast_expression 
  | postfix_expression }


unary_operator = {"-" | "~" | "!"}

// (* 6.5.4 *)
cast_expression = {
  ("(" ~ cast_expression ~ ":" ~ type_name ~ ")") 
  | (unary_expression)}

fby_expression = { 
  (cast_expression ~ "fby" ~ fby_expression) 
  | (cast_expression)}

// (* 6.5.5 *)
multiplicative_expression = { 
  (multiplicative_expression ~ "*" ~ fby_expression) 
  | (multiplicative_expression ~ "/" ~ fby_expression) 
  | (multiplicative_expression ~ "%" ~ fby_expression) 
  | fby_expression }

// (* 6.5.6 *)
additive_expression  = { 
    (additive_expression ~ "+" ~ multiplicative_expression) 
    |  (additive_expression ~ "-" ~ multiplicative_expression) 
    | multiplicative_expression }

// (* 6.5.7 *)
shift_expression     = {
    (shift_expression ~ "<<" ~ additive_expression) 
    | (shift_expression ~ ">>" ~ additive_expression) 
    | additive_expression}

when_expression  = { 
    (when_expression ~ "whenot" ~ identifier)
    | (when_expression ~ "when" ~ identifier)
    | shift_expression}

// (* 6.5.8 *)
relational_expression = { 
  (relational_expression ~ "<=" ~ when_expression) 
  | (relational_expression ~ ">=" ~ when_expression)
  | (relational_expression ~ "<" ~ when_expression)
  | (relational_expression ~ ">" ~ when_expression)
  | when_expression }

// (* 6.5.9 *)
equality_expression = {
  (equality_expression ~ "=" ~ relational_expression)
  | (equality_expression ~ "<>" ~ relational_expression)
  | relational_expression
}

// (* 6.5.10 *)
AND_expression = {
  (AND_expression ~ "and" ~ equality_expression)
  | equality_expression
}

// (* 6.5.11 *)
exclusive_OR_expression = { 
  (exclusive_OR_expression ~ "xor" ~ AND_expression)
  | (exclusive_OR_expression ~ "lxor" ~ AND_expression)
  | AND_expression
 }

// (* 6.5.12 *)
inclusive_OR_expression = {
  (inclusive_OR_expression ~ "lor" ~ exclusive_OR_expression)
  | exclusive_OR_expression
}

// (* 6.5.13 *)
logical_AND_expression = {
  (logical_AND_expression ~ "LAND" ~ inclusive_OR_expression)
  | inclusive_OR_expression
}

// (* 6.5.14 *)
logical_OR_expression = {
  (logical_OR_expression ~ "or" ~ logical_AND_expression)
  | logical_AND_expression
}
// (* Lustre Arrow Operator *)
arrow_expression = {
  (arrow_expression ~ "->" ~ logical_OR_expression)
  | logical_OR_expression
}

// (* 6.5.15/16/17, 6.6 + Lustre merge operator *)
// expression:
// | expr=arrow_expression
//     { expr }
// | loc=IFTE expr1=expression THEN expr2=expression ELSE expr3=expression
//     { [LustreAst.IFTE expr1 expr2 expr3 loc] }
// | loc=MERGE LPAREN id=VAR_NAME SEMICOLON expr1=expression SEMICOLON expr2=expression RPAREN
//     { [LustreAst.MERGE (fst id) expr1 expr2 loc] }
// | loc=MERGE id=VAR_NAME LPAREN TRUE  RARROW expr1=expression RPAREN
// 			LPAREN FALSE RARROW expr2=expression RPAREN
//     { [LustreAst.MERGE (fst id) expr1 expr2 loc] }
expression = { 
  ("merge" ~ identifier ~ "(" ~ "true" ~ "->" ~ expression ~")" ~ "(" ~ "false" ~ "->" ~ expression ~")")
  | ("merge" ~ "(" ~ identifier ~ ";" ~ expression ~ ";" ~ expression ~ ")")
  | ("if" ~ expression ~ "then" ~ expression ~ "else" ~ expression)
  | arrow_expression
}

// (* Declarations are much simpler than in C. We do not have arrays,
//    structs/unions, or pointers. We do not have storage-class specifiers,
//    type-qualifiers, or alignment specifiers. Nor are our type-specifiers lists
//    (e.g., "unsigned short int"), since we use the type names from
//    stdint.h/Scade (e.g., "uint_16"). *)

var_decl = { 
  (identifier_list ~ ":" ~ type_name ~ declared_clock) 
  | (identifier_list ~ ":" ~ type_name) }

// var_decl_list:
// | vars=var_decl
//     { vars }
// | vars_list=var_decl_list SEMICOLON vars=var_decl
//     { vars_list ++ vars }
var_decl_list = { 
  (var_decl_list ~ ";" ~ var_decl)
  | var_decl
}
// local_var_decl:
// | loc=VAR vars_list=var_decl_list SEMICOLON
//     { vars_list }
local_var_decl = { "var" ~ var_decl_list ~ ";"}

// identifier_list:
// | id=VAR_NAME
//     { [fst id] }
// | idl=identifier_list COMMA id=VAR_NAME
//     { fst id :: idl }
identifier_list = { 
  (identifier_list ~ "," ~ identifier)
  | identifier
}

type_name = {"int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "float32" | "float64" | "bool"}


declared_clock = {
  ("::" ~ clock)
  | ("whenot" ~ identifier)
  | ("when"   ~ identifier)
}

// clock:
// | DOT
//     { LustreAst.BASE }
// | clk=clock ON id=VAR_NAME
//     { LustreAst.ON clk (fst id) true }
// | clk=clock ONOT id=VAR_NAME
//     { LustreAst.ON clk (fst id) false }
clock = {
  (clock ~ "onot" ~ identifier)
  | (clock ~ "on" ~ identifier)
  | (".")
}


local_decl_list = {
  (local_decl_list ~ local_var_decl)
}


parameter_list = {
  (parameter_list ~ ";" ~ var_decl)
  | var_decl
}

pattern = {
  (pattern ~ "," ~ identifier)
  | identifier
}

equation = {
  (pattern ~ "=" ~ expression ~ ";")
  | ("(" ~ pattern ~ ")" ~ "=" ~ expression ~ ";" )
}

equations = {
  (equations ~ "assert" ~ expression ~ ";")
  | (equations ~ equation)
}

node_or_function = {
  "node" | "function"
}

// declaration:
// | is_node=node_or_function id=VAR_NAME
//   LPAREN iparams=oparameter_list RPAREN optsemicolon
//   RETURNS LPAREN oparams=oparameter_list RPAREN optsemicolon
//   locals=local_decl_list LET eqns=equations TEL optsemicolon
//     { LustreAst.NODE
//         (fst id) (fst is_node) iparams oparams locals eqns (snd is_node) }

declaration = {
  (node_or_function ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ ";"? 
    ~ "returns" ~ "(" ~ parameter_list ~ ")" ~ ";"? 
    ~ local_decl_list? ~ "let" ~ equations? ~ "tel" ~ ";"?)
}

translation_unit = {
  (translation_unit ~ declaration)
  | declaration
}


file = {(SOI ~ translation_unit ~ EOI) | (SOI ~ EOI)}

